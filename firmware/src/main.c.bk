#include "stm32f4xx_conf.h"
#include "stm32f4xx.h"

#include "pp-printf.h"
#include "biquad.h"
#include "usart.h"

extern void pwm_test();
int esc_get_speed();
float esc_get_speed_rps();
void esc_set_speed ( float setpoint_rps );
void esc_throttle_set(float value);
void fet_charge(int on);
void fet_break(int on);
int is_touchdown();
uint32_t get_ticks_count();


extern volatile int pcnt;

#define GAIN_SHIFT 12
struct bdf_state {
  int xd[10];
  int y;
};

double notch1_center = 460.0;
double notch2_center = 960.0;

struct servo_state {
    struct biquad lp_main;
    struct biquad peak_low;
    struct biquad peak_high;
    struct biquad notch1, notch2;

    struct bdf_state dfun;
    int gain_p, gain_d1;
    int gain_i;
    int bias;
    int integ;
};

void clock_info()
{
    RCC_ClocksTypeDef rcc;
    RCC_GetClocksFreq(&rcc);

    pp_printf("SWS: %d\n\r", rcc.sws);
    pp_printf("SYSCLK: %d Hz\n\r", rcc.SYSCLK_Frequency);
    pp_printf("AHB: %d Hz\n\r", rcc.HCLK_Frequency);
    pp_printf("APB1: %d Hz\n\r", rcc.PCLK1_Frequency);
    pp_printf("APB2: %d Hz\n\r", rcc.PCLK2_Frequency);
}



int bdf_update( struct bdf_state *st, int x )
{

  for(int i=9;i>=1;i--)
      st->xd[i] = st->xd[i-1];
  st->xd[0]= x;
  int y = 0;;
  y+=-4 * st->xd[8];
  y+=-3 * st->xd[7];
  y+=-2 * st->xd[6];
  y+=-1 * st->xd[5];
  y+=0 * st->xd[4];
  y+=1 * st->xd[3];
  y+=2 * st->xd[2];
  y+=3 * st->xd[1];
  y+=4 * st->xd[0];
  //y/=60;
  st->y=y;
  return y;
}

void bdf_init( struct bdf_state *st )
{
  int i;
  for(i=0;i<10;i++)
    st->xd[i] = 0;
}



#if 0
struct pd_control
{
  struct bdf_state dfun;
  float kp, kd;
  float y;
};

float adc_measure();


void pd_init( struct pd_control *pd )
{
  bdf_init(&pd->dfun);
}

float pd_update( struct pd_control *pd, float x )
{
  float d = bdf_update(&pd->dfun, x);
  pd->y = d * pd->kd + x * pd->kp;
  if(pd->y < 0.0)
    pd->y = 0.0;
  else if (pd->y > 2000.0)
    pd->y = 2000.0;

  return pd->y;
}

#endif

static struct servo_state servo;

volatile int servo_setpoint = 2400;

#define SERVO_SAMPLE_RATE 21341

#define SERVO_LOG_SIZE 12000

volatile int adc_samples = 0;

struct log_entry
{
  short setpoint;
  short error;
  short y;
} __attribute__((packed));

volatile struct log_entry servo_log[SERVO_LOG_SIZE];
volatile int servo_log_start = 0, servo_log_count = SERVO_LOG_SIZE;

static inline void servo_drive_set(int value)
{
  if(value > 1900)
    value = 1900;


  if( value < 0 )
  {
      TIM4->CCR3 = -value;
      TIM4->CCR2 = 0;
  } else {
      TIM4->CCR3 = 0;
      TIM4->CCR2 = value;
  }
}


int last_x =0 ;

static inline void servo_update(int x)
{
  int err = x - servo_setpoint;
  last_x = x;
servo.integ += err;

  int term_i = servo.gain_i * servo.integ;
  int term_p = servo.gain_p * err;
  int term_d1 = servo.gain_d1 * bdf_update(&servo.dfun, x) ;


  int y = servo.bias + ( (term_p + term_d1 + term_i ) >> GAIN_SHIFT );
  int yf = term_d1 >> GAIN_SHIFT; //servo.bias + ( (term_p + term_d1) >> GAIN_SHIFT );

  if( y > 1900 )
    y= 1900;
  else if (y<-1900)
    y=-1900;

  y = biquad_update(&servo.notch1, y);
  y = biquad_update(&servo.notch2, y);

  y = biquad_update(&servo.lp_main, y);

  servo_drive_set ( y );

    if(adc_samples > servo_log_start && servo_log_count < SERVO_LOG_SIZE)
    {
      servo_log[servo_log_count].setpoint = servo_setpoint;
      servo_log[servo_log_count].error = x;
      servo_log[servo_log_count].y = y;
      servo_log_count ++;
    }
}

void ADC_IRQHandler()
{
  GPIO_SetBits(GPIOB, GPIO_Pin_6);
  GPIO_ResetBits(GPIOB, GPIO_Pin_6);

  adc_samples++;
  int x = ADC_GetConversionValue(ADC1);
  ADC_ClearFlag(ADC1, ADC_FLAG_EOC);

  servo_update(x);
}


void servo_set_setpoint(float target)
{
  servo_setpoint = target;
}




void servo_adc_init()
{

  ADC_CommonInitTypeDef ADC_CommonInitStructure;

  /* Enable peripheral clocks *************************************************/
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);


  /* ADCs configuration ------------------------------------------------------*/
  /* Configure ADC Channel10, 11, 12 pin as analog input */


  GPIO_InitTypeDef GPIO_InitStructure;
  /* ADC Channel 10 -> PC0
     ADC Channel 11 -> PC1
     ADC Channel 12 -> PC2
  */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  // sample rate: 84 MHz / 8 / (480 + 12) = 21.341 kHz

  /* ADC Common Init */
  ADC_CommonInitStructure.ADC_Mode = ADC_DualMode_RegSimult;
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div8;
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
  ADC_CommonInit(&ADC_CommonInitStructure);

  ADC_InitTypeDef ADC_InitStructure;

  ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
  ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising;
  ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T4_CC4;
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  ADC_InitStructure.ADC_NbrOfConversion = 1;
  ADC_Init(ADC1, &ADC_InitStructure);

  /* ADC1 regular channels 10, 11 configuration */
  ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_480Cycles);

  NVIC_InitTypeDef NVIC_InitStructure;

  NVIC_InitStructure.NVIC_IRQChannel = ADC_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);

/* Enable ADC1 */
  ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);

  ADC_Cmd(ADC1, ENABLE);
  ADC_SoftwareStartConv(ADC1);

  //delay(10);
  //ADC_ITConfig(ADC1, ADC_IT_EOC, DISABLE);

}
//struct pd_control servo_pd;

void servo_init()
{
    biquad_init(&servo.lp_main, BIQUAD_TYPE_LOWPASS,SERVO_SAMPLE_RATE, 200.0,  1.0, 0.0);
    //biquad_init(&servo.notch1, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, 470.0,  10.0, -15.0);
    //biquad_init(&servo.notch2, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, 1000.0,  10.0, -15.0);
    //notch1_center = 510.0;
    //notch2_center = 990.0;

    biquad_init(&servo.notch1, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, notch1_center,  10.0, -20.0);
    biquad_init(&servo.notch2, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, notch2_center,  10.0, -20.0);
    //biquad_init(&servo.peak_low, BIQUAD_TYPE_BANDPASS,SERVO_SAMPLE_RATE, 2000.0,  1.707, 0.0);
    bdf_init( &servo.dfun );

    //biquad_init(&servo.peak_high, BIQUAD_TYPE_PEAK,SERVO_SAMPLE_RATE, 600.0,  0.707, 3.0);


    servo.gain_p = 16 * 270;//1.0 * 255; //0.8*255;
    servo.gain_d1 =  16 * 900; //3000;
    servo.gain_i = 2;
    servo.bias = 320;
    servo.integ = 0;
    servo_adc_init();
//    biquad_init)
 // pi_init(&servo_pd);
//  servo_pd.kp = 0.4;
//  servo_pd.kd = -0.01;//-1.0;
}

int wait_key()
{
  while(!usart_poll());
  return usart_rx_char();
}

void test_esc()
{
  //esc_init();
    motors_init();

    //esc_throttle_set(0.3);
    //throttle_set(250);
    esc_set_speed(20.0);

    int n = 0, dn = 1;


//    arc_test();

    //esc_throttle_set(0.25);


    for(;;)
    {
      //EXTI_GenerateSWInterrupt(EXTI_Line3);
      esc_control_update();
      //pp_printf("Pulses: %d cnt %d\n\r", pcnt,  TIM_GetCounter(TIM2) );
      //pp_printf("n %d dn %d ESC Speed %d %d\n\r", n, dn, esc_get_speed(), (int) esc_get_speed_rps() );
      delay(10);

  #if 0
  n+=dn;

      if(dn > 0)
        head_step(1);
      else
        head_step(0);

      if( n == 100 || n == 0)
      {
        dn = -dn;
      }
      #endif

    }

}

void test_gpio_pin( void *gpio, int pin )
{
  GPIO_InitTypeDef GPIO_InitStructure;

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

  GPIO_InitStructure.GPIO_Pin = pin; // TIM4/PWM3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(gpio, &GPIO_InitStructure);

  for(;;)
  {
    GPIO_SetBits(gpio, pin);
    delay(1);
    GPIO_ResetBits(gpio, pin);
    delay(1);
  }

}


void handle_kb()
{



    if (usart_poll())
    {
      int c = usart_rx_char();
      int new_setting = 1;

      switch(c)
      {
          case 'z': if(notch1_center > 100) notch1_center -= 3.0; break;
          case 'a': if(notch1_center < 2000) notch1_center += 3.0;break;
          case 'c': if(notch1_center > 100) notch2_center -= 3.0; break;
          case 'd': if(notch1_center < 2000) notch2_center += 3.0;break;
          case 's': servo.gain_d1 += 5; break;
          case 'x': servo.gain_d1 -= 5; break;
          case 'f': servo.gain_p += 5; break;
          case 'v': servo.gain_p -= 5; break;
          default:
        new_setting = 0;
      }

    if(new_setting)
    {
      pp_printf("notch1: %d notch2: %d gain-d: %d gain-p: %d\n\r", (int)notch1_center, (int)notch2_center, servo.gain_d1, servo.gain_p);
      biquad_init(&servo.notch1, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, notch1_center,  50.0, -30.0);
      biquad_init(&servo.notch2, BIQUAD_TYPE_PEAK, SERVO_SAMPLE_RATE, notch2_center,  50.0, -30.0);
    }
  }

}

int main(void)
{
    SystemInit();
    SysTick_Config(SystemCoreClock / 1000);


    GPIO_InitTypeDef  GPIO_InitStructure;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
//    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
//    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
//    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Speed = GPIO_Fast_Speed;
    GPIO_Init(GPIOA, &GPIO_InitStructure);



    usart_init();
    clock_info();
//    adc_test();

    pwm_init();


//    for(;;);

    hv_init();


    fet_charge(0);
    fet_break(0);

    //servo_drive_set(1000);

    servo_init();
    //servo_set_setpoint( 1000 );


   /* for(;;)
    {
      adc_samples = 0;
      delay(1000);
      pp_printf("samples: %d\n\r", adc_samples);
    }*/

    servo_set_setpoint(2000);

    delay(2000);
    //for(;;)
    {
      //pp_printf("s = start response test\n\r");
      //while(wait_key() != 's');

      pp_printf("Response test...\n\r");
      servo_log_start = 0;
      servo_log_count = 0;
      adc_samples = 0;

      delay(30);

      for(int i=0;i<3;i++)
      {
        servo_set_setpoint(2500);
        delay(50);
        servo_set_setpoint(2530);
        delay(50);
      }

      pp_printf("@respstart %d\n\r", servo_log_count);


      for(int i = 0; i < servo_log_count; i++)
      {
        pp_printf("@respdata %d %d %d %d\n\r", i, servo_log[i].setpoint, servo_log[i].error, servo_log[i].y);
      }

for(;;)
{
        //pp_printf("last_x %d\n\r",last_x);
        handle_kb();
      }

      servo_set_setpoint(2000);



    }

    for(;;);
    double t = 0.0;

    for(;;)
      {
        volatile double y = sin(t);
        t+=0.01;
        //pp_printf("t: %d\n\r", is_touchdown());
        servo_drive_set(0);
        while(!is_touchdown());
      //  delay(10);
        adc_measure();
        servo_drive_set(500);
        while(is_touchdown());
        //delay(10);
        servo_drive_set(200);

        //servo_drive_set(400);
        delay(50);
      }

    for(;;);



}

